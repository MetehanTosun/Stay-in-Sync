package de.unistuttgart.stayinsync.scriptengine;

import io.quarkus.logging.Log;
import jakarta.enterprise.context.ApplicationScoped;
import org.graalvm.polyglot.Source;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * An application-scoped cache for pre-parsed GraalVM {@link Source} objects.
 * This cache helps to avoid redundant parsing of scripts, especially for frequently executed scripts.
 * Scripts are identified by a combination of their ID and a hash of their content, allowing
 * different versions of the same script (by ID) to be cached.
 *
 * <p>Currently, this cache is primarily designed for JavaScript ("js") scripts, as indicated by
 * the script wrapping and {@code Source.newBuilder("js", ...)} calls.
 * The {@code TODO} comment suggests future extensions for other languages like Python or C-scripts.</p>
 *
 * @author Maximilian Peresunchak
 * @since 1.0
 */
@ApplicationScoped
public class ScriptCache {
    /**
     * The underlying concurrent map that stores the cached {@link Source} objects.
     * The key is a string generated by {@link #buildKey(String, String)}, and the value is the
     * pre-parsed {@link Source} object. Using {@link ConcurrentHashMap} ensures thread-safe access.
     */
    private final Map<String, Source> cache = new ConcurrentHashMap<>();

    /**
     * Retrieves a pre-parsed {@link Source} object from the cache.
     *
     * @param scriptId   The ID of the script.
     * @param scriptHash The hash of the script's content, representing a specific version.
     * @return The cached {@link Source} object if found, or {@code null} if the script
     * (with the specific ID and hash) is not in the cache.
     */
    public Source getScript(String scriptId, String scriptHash) {
        return cache.get(buildKey(scriptId, scriptHash));
    }

    /**
     * Checks if a script with the given ID and hash exists in the cache.
     * <p>
     * TODO: This method is marked as an extension point for language-specific caches,
     * implying future enhancements might involve different caching strategies for languages
     * like Python or C-scripts.
     * </p>
     *
     * @param scriptId   The ID of the script.
     * @param scriptHash The hash of the script's content.
     * @return {@code true} if the script is found in the cache, {@code false} otherwise.
     */
    public boolean containsScript(String scriptId, String scriptHash) {
        return cache.containsKey(buildKey(scriptId, scriptHash));
    }

    /**
     * Stores a pre-compiled {@link Source} object directly into the cache.
     * <p>
     * This method is the primary way to add items to the cache in the current architecture.
     * It assumes that the provided {@code Source} object has already been parsed from its string
     * representation and that any necessary pre-processing (such as wrapping user code in an IIFE)
     * has been performed by the caller.
     *
     * @param scriptId       The ID of the script, used as part of the cache key.
     * @param scriptHash     The hash of the original script's content, used for versioning.
     * @param compiledSource The pre-compiled {@link Source} object to be stored in the cache.
     */
    public void putCompiledScript(String scriptId, String scriptHash, Source compiledSource) {
        cache.put(buildKey(scriptId, scriptHash), compiledSource);
        Log.debugf("Cached compiled script: %s (with hash: %s)", scriptId, scriptHash);
    }

    /**
     * Generates a unique key for storing and retrieving scripts in the cache.
     * The key is a concatenation of the script ID and its hash, separated by a colon.
     * This allows caching multiple versions (identified by hash) of the same script (identified by ID).
     *
     * @param scriptId   The ID of the script.
     * @param scriptHash The generated unique hash of the script's content.
     * @return A string representing the unique key for the script version (e.g., "myScript:abcdef12345").
     */
    private String buildKey(String scriptId, String scriptHash) {
        return scriptId + ":" + scriptHash;
    }
}
