package de.unistuttgart.stayinsync.scriptengine;

import de.unistuttgart.stayinsync.exception.ScriptEngineException;
import io.quarkus.logging.Log;
import jakarta.enterprise.context.ApplicationScoped;
import org.graalvm.polyglot.PolyglotException;
import org.graalvm.polyglot.Source;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * An application-scoped cache for pre-parsed GraalVM {@link Source} objects.
 * This cache helps to avoid redundant parsing of scripts, especially for frequently executed scripts.
 * Scripts are identified by a combination of their ID and a hash of their content, allowing
 * different versions of the same script (by ID) to be cached.
 *
 * <p>Currently, this cache is primarily designed for JavaScript ("js") scripts, as indicated by
 * the script wrapping and {@code Source.newBuilder("js", ...)} calls.
 * The {@code TODO} comment suggests future extensions for other languages like Python or C-scripts.</p>
 *
 * @author Maximilian Peresunchak
 * @since 1.0
 */
@ApplicationScoped
public class ScriptCache {
    /**
     * The underlying concurrent map that stores the cached {@link Source} objects.
     * The key is a string generated by {@link #buildKey(String, String)}, and the value is the
     * pre-parsed {@link Source} object. Using {@link ConcurrentHashMap} ensures thread-safe access.
     */
    private final Map<String, Source> cache = new ConcurrentHashMap<>();

    /**
     * Retrieves a pre-parsed {@link Source} object from the cache.
     *
     * @param scriptId   The ID of the script.
     * @param scriptHash The hash of the script's content, representing a specific version.
     * @return The cached {@link Source} object if found, or {@code null} if the script
     * (with the specific ID and hash) is not in the cache.
     */
    public Source getScript(String scriptId, String scriptHash) {
        return cache.get(buildKey(scriptId, scriptHash));
    }

    /**
     * Checks if a script with the given ID and hash exists in the cache.
     * <p>
     * TODO: This method is marked as an extension point for language-specific caches,
     * implying future enhancements might involve different caching strategies for languages
     * like Python or C-scripts.
     * </p>
     *
     * @param scriptId   The ID of the script.
     * @param scriptHash The hash of the script's content.
     * @return {@code true} if the script is found in the cache, {@code false} otherwise.
     */
    public boolean containsScript(String scriptId, String scriptHash) {
        return cache.containsKey(buildKey(scriptId, scriptHash));
    }

    /**
     * Adds a script to the cache. The script code is wrapped in a JavaScript IIFE (Immediately Invoked Function Expression)
     * with "use strict" enabled before being parsed into a {@link Source} object.
     * This helps in isolating the script and enforcing stricter JavaScript rules.
     *
     * <p>If parsing or any other error occurs during the process, an error is logged, and the script
     * might not be added to the cache. The {@code TODO} comment indicates that parsing/compile
     * errors might require more sophisticated handling in the future.</p>
     *
     * @param scriptId   The ID of the script.
     * @param scriptHash The hash of the script's content, used for versioning.
     * @param scriptCode The raw source code of the script.
     * @throws ScriptEngineException if there were issues with I/O processing, script parsing errors or other unexpected
     *                               errors during script compilation phase.
     */
    public void putScript(String scriptId, String scriptHash, String scriptCode) {
        try {
            String wrappedScriptCode = "(function() {\n" +
                    "   \"use strict\";\n" +
                    scriptCode +
                    "\n})();";

            Source source = Source.newBuilder("js", wrappedScriptCode, scriptId)
                    .build();
            cache.put(buildKey(scriptId, scriptHash), source);
            Log.debugf("Cached script: %s (with hash: %s)", scriptId, scriptHash);
        } catch (IOException e) {
            String errorMsg = String.format("IOException while building source for script %s (id: %s)", scriptId, scriptHash);
            Log.errorf(e, errorMsg);
            throw new ScriptEngineException(
                    ScriptEngineException.ErrorType.SCRIPT_CACHING_ERROR,
                    "Script Caching I/O Error",
                    errorMsg,
                    e
            );
        } catch (PolyglotException e) {
            // TODO: Parsing/compile errors might require additional handling / features
            String errorMsg = String.format("Error parsing/pre-compiling script %s (id: %s): %s", scriptId, scriptHash, e.getMessage());
            Log.errorf(e, errorMsg);
            throw new ScriptEngineException(
                    ScriptEngineException.ErrorType.SCRIPT_PARSING_ERROR,
                    "Script Parsing Error",
                    errorMsg,
                    e
            );
        } catch (Exception e) {
            String errorMsg = String.format("Unexpected error putting script %s (id: %s) into cache: %s", scriptId, scriptHash, e.getMessage());
            Log.errorf(e, errorMsg);
            throw new ScriptEngineException(
                    ScriptEngineException.ErrorType.SCRIPT_CACHING_ERROR,
                    "Unexpected Script Caching Error",
                    errorMsg,
                    e
            );
        }
    }

    /**
     * Generates a unique key for storing and retrieving scripts in the cache.
     * The key is a concatenation of the script ID and its hash, separated by a colon.
     * This allows caching multiple versions (identified by hash) of the same script (identified by ID).
     *
     * @param scriptId   The ID of the script.
     * @param scriptHash The generated unique hash of the script's content.
     * @return A string representing the unique key for the script version (e.g., "myScript:abcdef12345").
     */
    private String buildKey(String scriptId, String scriptHash) {
        return scriptId + ":" + scriptHash;
    }
}
