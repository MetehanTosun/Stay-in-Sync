package de.unistuttgart.graphengine.logic_engine;

import com.fasterxml.jackson.databind.JsonNode;
import de.unistuttgart.graphengine.exception.GraphEvaluationException;
import de.unistuttgart.graphengine.nodes.ConfigNode;
import de.unistuttgart.graphengine.nodes.Node;
import de.unistuttgart.graphengine.nodes.SnapshotEntry;
import de.unistuttgart.graphengine.util.GraphTopologicalSorter;
import io.quarkus.logging.Log;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.transaction.Transactional;

import java.util.List;
import java.util.Map;

/**
 * Evaluates a logic graph composed of Node objects.
 */
@ApplicationScoped
public class LogicGraphEvaluator {

    @Inject
    GraphTopologicalSorter sorter;

    /**
     * Setter for injecting the sorter dependency, primarily for testing purposes.
     * @param sorter The GraphTopologicalSorter instance.
     */
    public void setSorter(GraphTopologicalSorter sorter) {
        this.sorter = sorter;
    }

    /**
     * A record to hold the complete result of a graph evaluation, containing both
     * the final boolean outcome and the newly generated snapshot for the next run.
     * @param finalResult The final boolean result from the graph's FinalNode.
     * @param newSnapshot The new state snapshot generated by the ConfigNode.
     */
    public record EvaluationResult(boolean finalResult, Map<String, SnapshotEntry> newSnapshot) {}

    /**
     * Evaluates a given valid, directed acyclic graph (DAG) of {@link Node}s.
     * <p>
     * The method executes all nodes in a topologically sorted order. It then extracts the
     * final boolean result from the graph's {@code FinalNode} and collects the new
     * state snapshot from the graph's {@code ConfigNode}. In case of any exception,
     * it creates and stores a debug snapshot before re-throwing the exception.
     *
     * @param allNodesInGraph A non-empty list containing all nodes that constitute the graph.
     * @param dataContext     A map containing the runtime data sources required by ProviderNodes,
     * and potentially the old snapshot under the "__snapshot" key.
     * @return An {@link EvaluationResult} object containing the final boolean result and the new snapshot.
     * @throws GraphEvaluationException if the provided list of nodes is null or empty, or if any
     * unexpected runtime error occurs during the evaluation process.
     */
    public EvaluationResult evaluateGraph(List<Node> allNodesInGraph, Map<String, JsonNode> dataContext) throws GraphEvaluationException {

        Map<String, SnapshotEntry> newSnapshot = null;

        if (allNodesInGraph == null || allNodesInGraph.isEmpty()) {
            Log.warn("Attempted to evaluate a null or empty graph. Throwing GraphEvaluationException.");
            throw new GraphEvaluationException(
                    GraphEvaluationException.ErrorType.INVALID_INPUT,
                    "Invalid Input",
                    "The list of graph nodes to evaluate cannot be null or empty.",
                    null);
        }
        Log.debugf("Starting evaluation of graph with %d nodes and data context keys: %s", allNodesInGraph.size(),
                dataContext.keySet());

        try {
            // Reset results on all nodes before evaluation.
            Log.debug("Resetting calculated results on all nodes before evaluation.");
            for (Node node : allNodesInGraph) {
                node.setCalculatedResult(null);
            }

            // 1. Get the topologically sorted list of nodes.
            Log.debug("Topologically sorting the graph to determine evaluation order.");
            List<Node> sortedNodes = sorter.sort(allNodesInGraph).sortedNodes();
            Log.debugf("Graph sorted. Evaluation order contains %d nodes.", sortedNodes.size());

            // 2. Evaluate each node in the correct order.
            Log.debug("Evaluating each node in topological order...");
            for (Node node : sortedNodes) {
                Log.tracef("Calculating node ID %d ('%s')...", node.getId(), node.getName());
                node.calculate(dataContext);
                if (node instanceof ConfigNode) {
                    newSnapshot = ((ConfigNode) node).getNewSnapshotData();
                }
                Log.tracef("...Node ID %d result: %s", node.getId(), node.getCalculatedResult());
            }

            // 3. Get the final boolean result ALWAYS from the FinalNode.
            Node finalTargetNode = sortedNodes.get(sortedNodes.size() - 1);
            boolean finalResult = (boolean) finalTargetNode.getCalculatedResult();
            Log.infof("Graph evaluation completed successfully. Final result: %b", finalResult);

            // 5. Return the complete EvaluationResult object.
            return new EvaluationResult(finalResult, newSnapshot);


        } catch (Exception e) {
            Log.errorf(e,
                    "An unexpected error occurred during graph evaluation.");
            throw new GraphEvaluationException(
                    GraphEvaluationException.ErrorType.EXECUTION_FAILED,
                    "Evaluation Failed",
                    "An unexpected error occurred during graph evaluation.",
                    e);
        }
    }
}